

<html data-theme="dark">
  <head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	
  <!-- font awesome -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css" integrity="sha384-oS3vJWv+0UjzBfQzYUhtDYW+Pj2yciDJxpsK1OYPAYjqT085Qq/1cq5FLXAZQ7Ay" crossorigin="anonymous">

  <link rel="stylesheet" href="/Blogs/static/main/css/classless.css">

  <style>

    @import url('https://fonts.googleapis.com/css2?family=Fira+Mono:wght@400;500;700&display=swap');


    html[data-theme='dark'] {
      /* foreground   | background color */
      --cfg:   #cdcdcd; --cbg:    #1b1b1b;
      --cdark: #999;    --clight: #343434; /*#333;*/
      --cmed:  #566;
      --clink: #1ad;
      --cemph: #0b9;    --cemphbg: #0b91;


      --font-p: 1.2em/1.7 "Fira Mono", monospace;
      --font-h: .9em/1.5 "Fira Mono", monospace; 
      --font-c: .9em/1.4 "Fira Mono", monospace;

      --width: 54rem;
      --navpos: fixed;
	    --ornament: "";
    }

    article * {
      scroll-margin-top: 9rem; 
    }

    p,
    article table{
      margin-top: 3rem;
    }

    article figure {
      text-align: center;
    }

    article figure img {
      background: #cdcdcd;
    }

    article h3:before {
      left: -0.5rem;
      margin-left: 0rem;
      font-size: 1.5rem;
    }

    article h2:before {
      left: -0.5rem;
      margin-left: -2rem;
      font-size: 1.5rem;
    }

    article h2.reference-title:before {
      display: none;
    }

    article ul {
      overflow: hidden;
    }

    

    a[href] {
      text-decoration: none;
    }

    

    nav ul:not(:first-child) li {
      padding: 0;
      margin: 0;
    }


    nav input[type="checkbox"]:hover + label, 
    nav input[type="checkbox"]:focus + label, 
    nav a.nav-active,
    nav a:hover, 
    nav a:focus {
      background: black;
    }


    nav li > a {
      display: block;
    }

    nav > span {
      height: inherit;
      background: inherit;
    }

    nav > span > input[type="checkbox"] {
      width: 0;
    }

    nav > span > input[type="checkbox"] + label { 
      color: var(--clink); cursor: pointer; 
    }


    nav > span > ul {
      background: inherit;
      display: inline-block;
      width: auto;
      margin: 0;
      padding: 0;
    }

    nav > span > input[type="checkbox"] + label {
      height: inherit;
      padding: 1rem 0.6rem;
    }

    nav > span > ul > li {
      height: 4rem;
      display: inline-block;
    }

    nav > span > ul > li > a {
      height: inherit;
      padding: 1rem 0.6rem;
    }

   
    nav > span.left-menu {
      float: left;
    }

    nav > span.left-menu > input[type="checkbox"] + label {
      float: left;
      display: none;
    }

    nav > span.left-menu > input[type="checkbox"] + label + ul {
      float: left;
      clear: left;
      
    }
    
    nav > span.left-menu > input[type="checkbox"] + label + ul > li{
      float: left;
    }

     
    nav > span.right-menu {
      float: right;
    }


    nav > span.right-menu > input[type="checkbox"] + label {
      float: right;
      display: inline-block;
    }

    nav > span.right-menu > input[type="checkbox"] + label + ul {
      display: none;
      float: right;
      clear: right;
      overflow-y: auto;
      max-height: 50vh;

      border: var(--border);
      border-radius: 4px;

    }

    nav > span.right-menu > input[type="checkbox"] + label + ul > li {
      display: block;
    }

    nav > span.right-menu > input[type="checkbox"]:hover + label + ul,
    nav > span.right-menu > input[type="checkbox"]:focus + label + ul,
    nav > span.right-menu > input[type="checkbox"] ~ ul:hover {
        display: inline-block;
    }

   
    body>nav {
      
      left: max(calc(50vw - var(--width)/2), 0vw);
      right: max(calc(50vw - var(--width)/2), 0vw);
      width: auto;
      height: 4rem;
      box-shadow: none;
      z-index: 100;
      overflow-y: visible;

    }

		article div.post-tags span {
			white-space: nowrap;
		}

    article div.post-tags span:not(:first-child):before
    {
			content: "|";
    }
  
   
    @media (max-width: 40rem) 
    {
      nav > span.left-menu > input[type="checkbox"] + label + ul > li {
        float: none;
        display: block;
      }
   
      nav > span.left-menu > input[type="checkbox"] + label {
        display: inline-block;
      }
      
      nav > span.left-menu > input[type="checkbox"] + label + ul {
        display: none;
      }

      nav > span.left-menu > input[type="checkbox"]:hover + label + ul,
      nav > span.left-menu > input[type="checkbox"]:focus + label + ul,
      nav > span.left-menu > input[type="checkbox"] + label + ul:hover {
        display: inline-block;
     

        overflow-y: auto;
        max-height: 50vh;

        border: var(--border);
        border-radius: 4px;
      }
          

    }

  </style>

  <title>
Looking into Label Smoothing
</title>
  
	
  </head>

<body style="margin-top: 0; padding-top: 0;">
<nav>
  <span class="left-menu">
  <input type="checkbox" id="nav-menu" />
  <label for="nav-menu">
  &nbsp;<i class="fas fa-bars"></i>&nbsp;&#x25BE;
  </label>

  <!--<a href="#">&nbsp;<i class="fas fa-bars"></i>&nbsp;&#x25BE;</a>-->
  <ul>
    <!--<li class="menu-hamburger">
    </li>-->
    
      
          
          <li>
            <a href="/Blogs/archives/"
            
            

            >Archives</a>                            
          </li>
      
          
          <li>
            <a href="/Blogs/tags/"
            
            

            >Tags</a>                            
          </li>
      
    
  </ul>
  </span>

  
  

</nav>

<main style='margin-top: 4rem; padding: 0 2rem; overflow-y: hidden;'>
  <article>
      
<script type="text/javascript"
          src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    /*inlineMath: [['$','$'], ['\\(','\\)']],*/
    inlineMath: [['$','$']],
    processEscapes: true},
    jax: ["input/TeX","input/MathML","input/AsciiMath","output/CommonHTML"],
    extensions: ["tex2jax.js","mml2jax.js","asciimath2jax.js","MathMenu.js","MathZoom.js","AssistiveMML.js", "[Contrib]/a11y/accessibility-menu.js"],
    TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"],
    equationNumbers: {
    autoNumber: "AMS"
    }
  }
});
</script>


<h1>Looking into Label Smoothing</h1>


<div class="post-tags">
  
  <span>
  <i class="fas fa-calendar"></i>&nbsp;<time>09.Mar.2020</time>
  </span>
  
  
  
  <span>
  <i class="fas fa-tags"></i>&nbsp;MachineLearning
  </span>
  
  
  
  <span>
  <i class="fas fa-tags"></i>&nbsp;Probability
  </span>
  
  
</div>



<p>I have forgotten where I obtained this impression about label smoothing: “Since data could be mislablled, to reflect the possibility of errors, labels are weighted to reduce our confidence about them.” While that description seems to present a straightforward intuition, it does not tell the full story, which I came to realise a few days ago after revisited this technique. So here are the missing pieces I have found.</p>
<h2>Regularisation</h2>
<p>Given a label $L$ represented as a one-hot vector $L_{\text{one-hot}}$ and the total number of classes $K$, the authors of label smoothing defined the smoothed vector $L_{\text{ls}}$ by a small proportion $\alpha$ as:</p>
<p>$$
\begin{equation}
\begin{aligned}
& L_{\text{ls}}[k] = (1 - \alpha) * L_{\text{one-hot}} [k] + \frac{\alpha}{K} \\
& where\,\,L_{\text{one-hot}}[k] =
\begin{cases}
1,& L = k \\
0,& otherwise
\end{cases}
\end{aligned}
\label{eq:labelSmoothing}
\end{equation}
$$</p>
<p>Most probability models fitting categorical distributions are optimised towards a lower expected cross entropy between model estimations and labels. Suppose $P$ is a vector of probabilities for different classes outputted by a model; with the notations from \eqref{eq:labelSmoothing}, the cross entropy $E_{\text{one-hot}}$ between $L_{\text{one-hot}}$ and $P$ is</p>
<p>$$
\begin{aligned}
& E_{\text{one-hot}} = - \sum_{i=0}^K L_{\text{one-hot}} [i] * log(P[i]) = log(P[k]), L = k
\end{aligned}
$$</p>
<p>If the one-hot version of labels is replaced with the smoothed one, a different version of cross entropy, $E_{\text{ls}}$ can be obtained:</p>
<p>$$
\begin{aligned}
& E_{\text{ls}} = - \sum_{i=0}^K L_{\text{ls}} [i] * log(P[i]) \\
& \phantom{ E_{\text{ls}}} = - \sum_{i=0}^K [(1 - \alpha) * L_{\text{one-hot}} [i] + \frac{\alpha}{K}] * log(P[i]) \\
& \phantom{ E_{\text{ls}}} = (1 - \alpha) * (-1) * \sum_{i=0}^K L_{\text{one-hot}} [i] * log(P[i]) \\
& \phantom{ E_{\text{ls}} = } - \alpha * \sum_{i=0}^K \frac{1}{K} * log(P[i]) \\
& \phantom{ E_{\text{ls}}} = (1 - \alpha) * E_{\text{one-hot}} - \alpha * \sum_{i=0}^K \frac{1}{K} * (log(P[i]) - log(\frac{1}{K})) \\
& \phantom{ E_{\text{ls}} = } - \alpha * \sum_{i=0}^K \frac{1}{K} log(\frac{1}{K}) \\
& \phantom{ E_{\text{ls}}} = (1 - \alpha) * E_{\text{one-hot}} + \alpha * KL[\text{Uniform}_K \lVert P] \\
& \phantom{ E_{\text{ls}} = } + \alpha * Entropy(\text{Uniform}_K)
\end{aligned}
$$</p>
<p>Since $Entropy(\text{Uniform}_K)$ is a constant, the minimisation of $E_{\text{ls}}$ for a model effectively achieves two things:</p>
<ol>
<li>Minimise $E_{\text{one-hot}}$, which is the original optimisation objective of the model, with a weight of $ (1 - \alpha)$.</li>
<li>Minimise $KL[\text{Uniform}_K \lVert P]$, which serves as a <strong>regularisor</strong> to bring the distribution of $P$ towards the one of $\text{Uniform}_K$, with a weight of $\alpha$.</li>
</ol>
<p>So “reduce confidence” can be seen as the result of regularisation which causes models to produce flatter distributions.</p>
<h2>Calibration</h2>
<p>When doing classification, one will usually use softmax as the final step to produce a vector of the length equal to the number of classes. Despite the fact that all entries in that vector add up to 1, it does not necessarily mean that vector (approximately) describes a distribution of classes. For example, if the result of its two-class classification is $[0.9, 0.1]$, in the case of <strong>uncalibrated models</strong> that only implies the first class receives a higher (normalised) score, and hence has a higher rank, than the second class does. As for the purpose of mere classification, ranking does do the job; nonetheless, there are some scenarios where distributions of classes are required, so that the accuracy of decisions (the probability that a chosen class is correct) can be estimated, or samples following the same distributions can be generated. To that end, we need to <strong>calibrate</strong> our model, and one way to achieve that is to apply label smoothing during training.</p>
<p>But, why does label smoothing have such power? A recent paper has presented an interesting insight into the penultimate layer, right before softmax, of classification models, and I would like to add my own interpretation based on their finding to offer some intuition. </p>
<p>First, in most cases, a penultimate layer only involves a linear transformation:</p>
<p>$$
\begin{aligned}
y_k(x) = x^T \odot w_k
\end{aligned}
$$</p>
<p>where $x$ is the input to the penultimate layer, and $w_k$ describes the linear mapping which produces the logit for class $k$. The softmax output for class $k$ given $x$, $s_k(x)$, can then be expressed in terms of $x^T \odot w_k$ (assuming the total number of classes is $K$).</p>
<p>$$
\begin{equation}
\begin{aligned}
s_k(x) = \frac{exp(x^T \odot w_k)}{\sum_{i=1}^{K} exp(x^T \odot w_i)}
\end{aligned}
\label{eq:softmax}
\end{equation}
$$</p>
<p>Since the multiplication of both numerator and denominator in \eqref{eq:softmax} by the same constant factors will not change the ratio, \eqref{eq:softmax} can be further derived as follows:</p>
<p>$$
\begin{equation}
\begin{aligned}
& s_k(x) = \frac{exp(-0.5 \lVert x \rVert_2^2) * exp(-0.5 \lVert w_{max} \rVert_2^2)}{exp(-0.5 \lVert x \rVert_2^2) * exp(-0.5 \lVert w_{max} \rVert_2^2)} \\
& \phantom{s_k(x) =} * \frac{exp(x^T \odot w_k)}{\sum_{i=1}^{K} exp(x^T \odot w_i)} \\
& \phantom{s_k(x)} = \frac{exp(-0.5 \lVert x \rVert_2^2 + x^T \odot w_k - 0.5 \lVert w_{max} \rVert_2^2)}{\sum_{i=1}^{K} exp(-0.5 \lVert x \rVert_2^2 + x^T \odot w_i – 0.5 \lVert w_{max} \rVert_2^2)} \\
& \phantom{s_k(x)} = \frac{exp(-0.5 * (\lVert x \rVert_2^2 - 2 * x^T \odot w_k + \lVert w_{max} \rVert_2^2))}{\sum_{i=1}^{K} exp(-0.5 * (\lVert x \rVert_2^2 - 2 * x^T \odot w_i + \lVert w_{max} \rVert_2^2))} \\
& \phantom{s_k(x)} = \frac{exp(-0.5 * z(x, w_k))}{\sum_{i=1}^{K} exp(-0.5 * z(x, w_i))}
\end{aligned}
\label{eq:softmax2}
\end{equation}
$$</p>
<p>where $w_{max}$ refers to the vector with the largest length among all $w_i$, $i \in \{ j \lvert j \in \mathbb{Z}, 0 \leq j \leq K \}$; also the last equality is put in for simplification, by letting $z(x, w) = \lVert x \rVert_2^2 - 2 * x^T \odot w + \lVert w_{max} \rVert_2^2$.</p>
<p>One might notice a high degree of similarity between the terms in the function $z$ and the ones which would have been involved in a L2 norm. In effect, they can be linked through the following inequality:</p>
<p>$$
\begin{equation}
\begin{aligned}
& z(x, w_i) = \lVert x \rVert_2^2 - 2 * x^T \odot w_i + \lVert w_{max} \rVert_2^2 \\
& \phantom{z(x, w_i)} \geq \lVert x \rVert_2^2 - 2 * x^T \odot w_i + \lVert w_{i} \rVert_2^2 \\
& \phantom{z(x, w_i)} = \lVert x - w_i \rVert_2^2 \geq 0
\end{aligned}
\label{eq:L2Inequality}
\end{equation}
$$</p>
<p>Meanwhile, \eqref{eq:softmax2} also suggests that a model trained with some example from class $k$ of which the penultimate representation is $x$ will produce small $z(x, w_k)$ and large $z(x, w_l)$ for all other classes $l \neq k$, so that the distinct differences between them can result in dominant $s_k(x)$ with tiny $s_l(x)$ to reflect the labelling. Since according to \eqref{eq:L2Inequality}, the function $z$ describes an upper bound of the L2 norm squared of the difference between its two input arguments, it can be further inferred that $\lVert x - w_k \rVert_2^2$ should be small while there is room for $\lVert x - w_l \rVert_2^2$ to grow. From a geometric perspective, if $x$ and $w_k$/$w_l$ are viewed as points in a hyperspace, the relation, in terms of bounds of L2 norms, between those points loosely describes a form of clustering, with cluster centres being $w_k$/$w_l$.</p>
<p>
<figure><img alt="PenultimateClustering.png" src="/Blogs/static/main/images/LabelSmoothing/PenultimateClustering.png" /><figcaption>A schematic diagram for the geometric view of $x$ and $w_k$/$w_l$</figcaption>
</figure>
</p>
<p>This phenomenon of clustering is one of the discoveries presented in the aforementioned paper; besides, the authors also explored the effect of label smoothing to the widths of clusters, on which my interpretation is as follows:</p>
<ul>
<li>
<p>When a model is trained given labels in one-hot encoding, $z(x, w_l)$ can become quite large as $s_l(x)$ is approaching 0. In fact, there is no theoretical upper bound for it; at the same time, rising $z(x, w_l)$ will also boost $s_k(x)$, so $z(x, w_k)$ does not have to be very small to generate a dominant response of softmax for class $k$. That potential increase in $z(x, w_k)$, which corresponds to the upper bounds of the distances between $x$ and $w_k$, suggests the possible presence of broad clusters.</p>
</li>
<li>
<p>The use of label smoothing essentially limits the growth of $z(x, w_l)$ so that the resulting $s_l(x)$ can account for the slight probability assigned to class $l$. That also makes minimisation of $z(x, w_k)$ more necessary as $s_k(x)$ cannot be further increased by unboundedly large $z(x, w_l)$. Therefore, in contrast to the case where one-hot encoding is directly employed, clusters are more likely to be tighter due to a smaller distance bound $z(x, w_k)$ under the effect of label smoothing.</p>
</li>
</ul>
<p>One of the advantanges of connecting penultimate layers with clustering is that it offers a different way to understand the subsequent softmax. The equivalent form of the softmax, \eqref{eq:softmax2}, can now be seen an approximation of the posterior probabilities of classes given data under a Gaussian Mixture model, with the assumption that the covariance matrix of every Gaussian is $I * \sigma^2$, $\sigma^2 = 1$, and the prior for classes is a uniform distribution. That assumption, $\sigma^2 = 1$ in particular, implies the probability model is not suitable for data coming from broad clusters, since it cannot estimate their posterior probabilities very well, or to put it differently, is <strong>uncalibrated</strong>.</p>
<p>As mentioned earlier, without label smoothing, the clusters formed by the inputs to the penultimate layer could end up with large widths. In that case, bad calibration occurs because the distribution of those inputs cannot be fitted properly under the model assumption of $\sigma^2 = 1$; this analysis might also explain why previous researches have found temperature scaling, which divides the logits to the softmax function by a constant named temperature $T$, can help to calibrate models:</p>
<p>$$
\begin{aligned}
s_k^{\text{TS}}(x) = \frac{exp(\frac{x^T \odot w_k}{T})}{\sum_{i=1}^{K} exp(\frac{x^T \odot w_i}{T})}
\end{aligned}
$$</p>
<p>Since it is equivalent to dividing the function $z$ by $T$ in \eqref{eq:softmax2}, the scaling in effect adjusts $\sigma^2$ so that the sizes of clusters can be better described. Similarly, label smoothing provides the effect of improving the degree of calibration by matching the probability model to the underlying data as temperature scaling does, but it achieves that through encouraging tighter clusters, and hence increasing the validity of $\sigma^2 = 1$.</p>
<h2 class="reference-title">References</h2>
<ul>
<li><a href="https://arxiv.org/abs/1906.02629">Rafael M&#x00FC;ller, Simon Kornblith, and Geoffrey E.Hinton. “When Does Label Smoothing Help?” In:CoRRabs/1906.02629 (2019).</a></li>
</ul>

</br></br></br></br>

  </article>
</main>

</body>
</html>
